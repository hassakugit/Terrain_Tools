<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robust High-Resolution Terrain Generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .top-bar {
            background: rgba(255,255,255,0.1);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
        }
        
        .logo {
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .data-source-selector {
            background: white;
            border-radius: 6px;
            padding: 8px 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .data-source-selector select {
            border: none;
            background: none;
            font-size: 14px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
            outline: none;
        }
        
        .container {
            max-width: 1400px;
            margin: 20px auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .header h1 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
        }
        
        .map-container {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            overflow: hidden;
        }
        
        #map {
            width: 100%;
            height: 600px;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #dee2e6;
            max-height: 900px;
            overflow-y: auto;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        
        .control-group input,
        .control-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .button {
            width: 100%;
            padding: 12px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px 0;
        }
        
        .button:hover {
            background: #5a6fd8;
        }
        
        .button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .button.cancel {
            background: #dc3545;
        }
        
        .button.cancel:hover {
            background: #c82333;
        }
        
        .status {
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: 500;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .progress-container {
            display: none;
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 2px solid #667eea;
        }
        
        .progress-container.active {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 15px;
            background: #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .progress-details {
            font-size: 0.9rem;
            color: #555;
            margin-top: 10px;
        }
        
        .eta-display {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.9rem;
        }
        
        .info-box {
            background: #f0f8ff;
            border: 1px solid #b3d9ff;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            color: #856404;
        }
        
        .selection-info {
            background: #e8f5e8;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }
        
        .range-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .range-group input[type="range"] {
            flex: 1;
        }
        
        .range-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }
        
        .api-key-group {
            display: none;
        }
        
        .api-key-field {
            margin-bottom: 15px;
        }
        
        .api-key-field label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        
        .api-key-group.active {
            display: block;
        }
        
        .source-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.85rem;
        }
        
        .time-estimate {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.9rem;
            color: #856404;
        }
        
        .batch-info {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.85rem;
        }
        
        .memory-info {
            background: #fce4ec;
            border: 1px solid #f8bbd9;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.85rem;
            color: #880e4f;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            #map {
                height: 400px;
            }
            
            .top-bar {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="logo">üèîÔ∏è Robust High-Resolution Terrain Generator</div>
        <div class="data-source-selector">
            <select id="dataSource" onchange="onDataSourceChange()">
                <option value="google">Google Maps API</option>
                <option value="opentopo">OpenTopography.org</option>
                <option value="usgs">USGS Elevation Point Query</option>
                <option value="openelev">Open-Elevation API</option>
            </select>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>üåç Robust High-Resolution Terrain Generator</h1>
            <p>Generate ultra-high resolution terrain with memory-safe processing for millions of points</p>
        </div>

        <div class="main-content">
            <div class="map-container">
                <div id="map"></div>
            </div>

            <div class="controls">
                <div id="sourceInfo" class="info-box">
                    <strong>üìä Google Maps API</strong><br>
                    Memory-safe batch processing for unlimited resolution.
                </div>

                <div id="apiKeyGroup" class="control-group api-key-group active">
                    <div id="googleApiKey" class="api-key-field">
                        <label for="googleKey">Google Maps API Key:</label>
                        <input type="password" id="googleKey" placeholder="Enter your Google Maps API key">
                    </div>
                    
                    <button class="button" onclick="loadMap()" id="loadBtn">Load Map</button>
                </div>

                <div id="openSourceGroup" class="control-group api-key-group">
                    <div class="info-box">
                        <strong>üÜì Open Source Data</strong><br>
                        Memory-optimized processing for massive datasets.
                    </div>
                    <button class="button" onclick="loadOpenSourceMap()" id="loadOpenBtn">Load Open Source Map</button>
                </div>

                <div class="selection-info" id="selectionInfo">
                    <strong>üìç Selected Area:</strong><br>
                    <span id="boundsText"></span><br>
                    <span id="areaText"></span>
                </div>

                <div class="control-group">
                    <label for="resolution">Resolution (Memory-Safe):</label>
                    <select id="resolution" onchange="updateEstimates()">
                        <option value="200">200√ó200 (40K points) - 15-30 min</option>
                        <option value="500" selected>500√ó500 (250K points) - 1-2 hours</option>
                        <option value="1000">1000√ó1000 (1M points) - 3-6 hours</option>
                        <option value="1500">1500√ó1500 (2.25M points) - 6-12 hours</option>
                        <option value="2000">2000√ó2000 (4M points) - 12-24 hours</option>
                        <option value="3000">3000√ó3000 (9M points) - 24-48 hours</option>
                        <option value="4000">4000√ó4000 (16M points) - 48-96 hours</option>
                        <option value="5000">5000√ó5000 (25M points) - 3-7 days</option>
                    </select>
                </div>

                <div id="memoryInfo" class="memory-info">
                    <strong>üíæ Memory Management:</strong><br>
                    <span id="memoryText">Streaming processing prevents memory overflow</span>
                </div>

                <div id="timeEstimate" class="time-estimate">
                    <strong>‚è±Ô∏è Estimated Time:</strong><br>
                    <span id="estimateText">Select resolution for estimate</span>
                </div>

                <div id="batchInfo" class="batch-info">
                    <strong>üì¶ Batch Processing:</strong><br>
                    <span id="batchText">Intelligent chunking with memory optimization</span>
                </div>

                <div class="control-group">
                    <label for="batchSize">Batch Size (Memory-Safe):</label>
                    <select id="batchSize" onchange="updateEstimates()">
                        <option value="50">50 points - Ultra-safe</option>
                        <option value="100" selected>100 points - Balanced</option>
                        <option value="200">200 points - Faster</option>
                        <option value="300">300 points - Maximum</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="batchDelay">Delay Between Batches (ms):</label>
                    <select id="batchDelay" onchange="updateEstimates()">
                        <option value="500">500ms - Fast</option>
                        <option value="1000" selected>1000ms - Safe</option>
                        <option value="1500">1500ms - Conservative</option>
                        <option value="2000">2000ms - Ultra-safe</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="chunkSize">Processing Chunk Size:</label>
                    <select id="chunkSize" onchange="updateEstimates()">
                        <option value="50000">50K points - Safe for 8GB RAM</option>
                        <option value="100000" selected>100K points - Balanced</option>
                        <option value="200000">200K points - Fast (16GB+ RAM)</option>
                        <option value="500000">500K points - Maximum (32GB+ RAM)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="exaggeration">Terrain Exaggeration: <span id="exagValue">2.0√ó</span></label>
                    <div class="range-group">
                        <input type="range" id="exaggeration" min="0.5" max="5" step="0.1" value="2" 
                               oninput="document.getElementById('exagValue').textContent = this.value + '√ó'">
                    </div>
                </div>

                <div class="control-group">
                    <label for="baseHeight">Base Height (mm):</label>
                    <input type="number" id="baseHeight" value="5" min="1" max="20">
                </div>

                <div class="control-group">
                    <label for="modelSize">Model Size (mm):</label>
                    <input type="number" id="modelSize" value="150" min="50" max="500">
                </div>

                <div class="progress-container" id="progressContainer">
                    <div><strong id="progressTitle">Memory-Safe Processing...</strong></div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div id="progressText">Initializing streaming processor...</div>
                    <div class="progress-details" id="progressDetails">
                        Chunk: 0/0 | Batch: 0/0 | Points: 0/0 | Memory: OK
                    </div>
                    <div class="eta-display" id="etaDisplay" style="display: none;">
                        <strong>üìä Real-time Statistics:</strong><br>
                        <span id="statsText">Processing...</span>
                    </div>
                </div>

                <button class="button" id="generateBtn" onclick="generateModel()" disabled>
                    üöÄ Generate Memory-Safe Model
                </button>

                <button class="button cancel" id="cancelBtn" onclick="cancelGeneration()" style="display: none;">
                    ‚ùå Cancel Generation
                </button>

                <div id="status"></div>
            </div>
        </div>
    </div>

    <script>
        let map, rectangle, selectedBounds = null;
        let mapLoaded = false;
        let isProcessing = false;
        let isCancelled = false;
        let elevationService = null;
        let currentDataSource = 'google';
        let processingStartTime = null;
        let processedBatches = 0;
        let totalBatches = 0;

        // Memory management for ultra-high resolution
        let elevationChunks = []; // Store data in chunks instead of one massive array
        let processedChunks = 0;
        let totalChunks = 0;

        const dataSources = {
            google: {
                name: 'Google Maps API',
                description: 'Memory-safe batch processing for unlimited resolution.',
                requiresKey: true,
                maxBatchSize: 512,
                rateLimit: 50,
                pointsPerMinute: 2500,
                reliabilityFactor: 1.0
            },
            opentopo: {
                name: 'OpenTopography.org',
                description: 'Memory-optimized processing for massive datasets.',
                requiresKey: false,
                maxBatchSize: 100,
                rateLimit: 20,
                pointsPerMinute: 800,
                reliabilityFactor: 0.7
            },
            usgs: {
                name: 'USGS Elevation Point Query',
                description: 'Streaming processing for US elevation data.',
                requiresKey: false,
                maxBatchSize: 50,
                rateLimit: 15,
                pointsPerMinute: 400,
                reliabilityFactor: 0.8
            },
            openelev: {
                name: 'Open-Elevation API',
                description: 'Memory-safe processing for global SRTM data.',
                requiresKey: false,
                maxBatchSize: 25,
                rateLimit: 10,
                pointsPerMinute: 200,
                reliabilityFactor: 0.9
            }
        };

        function onDataSourceChange() {
            const dataSource = document.getElementById('dataSource').value;
            currentDataSource = dataSource;
            const sourceConfig = dataSources[dataSource];
            
            document.getElementById('sourceInfo').innerHTML = `
                <strong>üìä ${sourceConfig.name}</strong><br>
                ${sourceConfig.description}<br>
                <small>Rate: ~${sourceConfig.pointsPerMinute} points/min | Memory-safe processing</small>
            `;
            
            const apiKeyGroup = document.getElementById('apiKeyGroup');
            const openSourceGroup = document.getElementById('openSourceGroup');
            
            if (sourceConfig.requiresKey) {
                apiKeyGroup.classList.add('active');
                openSourceGroup.classList.remove('active');
            } else {
                apiKeyGroup.classList.remove('active');
                openSourceGroup.classList.add('active');
            }
            
            updateBatchSizeOptions();
            updateEstimates();
            
            mapLoaded = false;
            selectedBounds = null;
            if (rectangle) {
                if (rectangle.setMap) {
                    rectangle.setMap(null);
                } else if (map && map.removeLayer) {
                    map.removeLayer(rectangle);
                }
                rectangle = null;
            }
            updateSelectionInfo();
            checkGenerateButton();
            
            showStatus(`Switched to ${sourceConfig.name}. Memory-safe processing enabled.`, 'info');
        }

        function updateBatchSizeOptions() {
            const sourceConfig = dataSources[currentDataSource];
            const batchSizeSelect = document.getElementById('batchSize');
            const currentValue = batchSizeSelect.value;
            
            batchSizeSelect.innerHTML = '';
            
            if (sourceConfig.maxBatchSize >= 300) {
                batchSizeSelect.innerHTML += '<option value="50">50 points - Ultra-safe</option>';
                batchSizeSelect.innerHTML += '<option value="100">100 points - Safe</option>';
                batchSizeSelect.innerHTML += '<option value="200">200 points - Balanced</option>';
                batchSizeSelect.innerHTML += '<option value="300">300 points - Fast</option>';
                if (sourceConfig.maxBatchSize >= 500) {
                    batchSizeSelect.innerHTML += '<option value="500">500 points - Maximum</option>';
                }
            } else if (sourceConfig.maxBatchSize >= 100) {
                batchSizeSelect.innerHTML += '<option value="25">25 points - Ultra-safe</option>';
                batchSizeSelect.innerHTML += '<option value="50">50 points - Safe</option>';
                batchSizeSelect.innerHTML += '<option value="75">75 points - Balanced</option>';
                batchSizeSelect.innerHTML += '<option value="100">100 points - Maximum</option>';
            } else {
                batchSizeSelect.innerHTML += '<option value="10">10 points - Ultra-safe</option>';
                batchSizeSelect.innerHTML += '<option value="25">25 points - Safe</option>';
                batchSizeSelect.innerHTML += '<option value="50">50 points - Maximum</option>';
            }
            
            if (batchSizeSelect.querySelector(`option[value="${currentValue}"]`)) {
                batchSizeSelect.value = currentValue;
            } else {
                batchSizeSelect.value = sourceConfig.maxBatchSize >= 100 ? '100' : '25';
            }
        }

        function calculateTimeEstimate() {
            const resolution = parseInt(document.getElementById('resolution').value);
            const batchSize = parseInt(document.getElementById('batchSize').value);
            const batchDelay = parseInt(document.getElementById('batchDelay').value);
            const chunkSize = parseInt(document.getElementById('chunkSize').value);
            const sourceConfig = dataSources[currentDataSource];
            
            const totalPoints = (resolution + 1) * (resolution + 1);
            const totalBatches = Math.ceil(totalPoints / batchSize);
            const totalChunks = Math.ceil(totalPoints / chunkSize);
            
            const processingTimePerBatch = (batchDelay / 1000) + 2;
            const baseProcessingTime = totalBatches * processingTimePerBatch;
            const adjustedTime = baseProcessingTime / sourceConfig.reliabilityFactor;
            
            // Add STL generation time (scales with resolution)
            const stlGenerationTime = totalPoints / 50000; // ~50K triangles per second
            const totalTime = adjustedTime + stlGenerationTime;
            
            const days = Math.floor(totalTime / 86400);
            const hours = Math.floor((totalTime % 86400) / 3600);
            const minutes = Math.floor((totalTime % 3600) / 60);
            
            let formattedTime;
            if (days > 0) {
                formattedTime = `${days}d ${hours}h ${minutes}m`;
            } else if (hours > 0) {
                formattedTime = `${hours}h ${minutes}m`;
            } else {
                formattedTime = `${minutes}m`;
            }
            
            return {
                totalPoints,
                totalBatches,
                totalChunks,
                estimatedSeconds: totalTime,
                formattedTime,
                memoryUsageMB: Math.ceil(chunkSize * 32 / 1024 / 1024) // Rough estimate
            };
        }

        function updateEstimates() {
            const estimate = calculateTimeEstimate();
            
            document.getElementById('estimateText').innerHTML = `
                <strong>${estimate.formattedTime}</strong> for ${estimate.totalPoints.toLocaleString()} points<br>
                <small>Includes elevation fetching + STL generation</small>
            `;
            
            document.getElementById('batchText').innerHTML = `
                ${estimate.totalBatches.toLocaleString()} batches √ó ${document.getElementById('batchSize').value} points<br>
                <small>Processed in ${estimate.totalChunks} memory-safe chunks</small>
            `;
            
            document.getElementById('memoryText').innerHTML = `
                ~${estimate.memoryUsageMB}MB per chunk, ${estimate.totalChunks} chunks total<br>
                <small>Prevents "too many arguments" errors</small>
            `;
            
            // Update warning colors
            const timeEstimateDiv = document.getElementById('timeEstimate');
            if (estimate.estimatedSeconds > 172800) { // 2 days
                timeEstimateDiv.style.background = '#f8d7da';
                timeEstimateDiv.style.color = '#721c24';
                timeEstimateDiv.style.borderColor = '#f5c6cb';
            } else if (estimate.estimatedSeconds > 43200) { // 12 hours
                timeEstimateDiv.style.background = '#fff3cd';
                timeEstimateDiv.style.color = '#856404';
                timeEstimateDiv.style.borderColor = '#ffeaa7';
            } else {
                timeEstimateDiv.style.background = '#d4edda';
                timeEstimateDiv.style.color = '#155724';
                timeEstimateDiv.style.borderColor = '#c3e6cb';
            }
        }

        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.className = `status ${type}`;
            status.textContent = message;
        }

        function showProgress(show, progress = 0, text = '', details = '') {
            const container = document.getElementById('progressContainer');
            if (show) {
                container.classList.add('active');
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressText').textContent = text;
                if (details) {
                    document.getElementById('progressDetails').textContent = details;
                }
            } else {
                container.classList.remove('active');
            }
        }

        function updateRealTimeStats(chunkIndex, batchIndex, totalBatches, processedPoints, totalPoints, avgTimePerBatch) {
            const elapsed = (Date.now() - processingStartTime) / 1000;
            const remaining = (totalBatches - batchIndex) * avgTimePerBatch;
            
            const eta = new Date(Date.now() + remaining * 1000);
            const completionRate = processedPoints / elapsed;
            
            document.getElementById('etaDisplay').style.display = 'block';
            document.getElementById('statsText').innerHTML = `
                Processing Rate: <strong>${Math.round(completionRate)} points/sec</strong><br>
                Chunk: <strong>${chunkIndex + 1}/${totalChunks}</strong> | Memory: <strong>OK</strong><br>
                Elapsed: <strong>${Math.floor(elapsed/60)}m ${Math.floor(elapsed%60)}s</strong><br>
                ETA: <strong>${eta.toLocaleTimeString()}</strong>
            `;
        }

        function loadMap() {
            const apiKey = document.getElementById('googleKey').value.trim();
            
            if (!apiKey) {
                showStatus('Please enter your Google Maps API key.', 'error');
                return;
            }

            showStatus('Loading Google Maps...', 'info');
            
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=drawing&callback=initGoogleMap`;
            script.onerror = () => showStatus('Failed to load Google Maps. Check your API key.', 'error');
            
            window.initGoogleMap = initGoogleMap;
            document.head.appendChild(script);
        }

        function loadOpenSourceMap() {
            showStatus('Loading OpenStreetMap...', 'info');
            
            if (!window.L) {
                const leafletCSS = document.createElement('link');
                leafletCSS.rel = 'stylesheet';
                leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                document.head.appendChild(leafletCSS);
                
                const leafletJS = document.createElement('script');
                leafletJS.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                leafletJS.onload = initOpenSourceMap;
                document.head.appendChild(leafletJS);
            } else {
                initOpenSourceMap();
            }
        }

        function initGoogleMap() {
            try {
                showStatus('Google Maps loaded! Draw a rectangle to select terrain area.', 'success');
                mapLoaded = true;
                
                map = new google.maps.Map(document.getElementById('map'), {
                    zoom: 10,
                    center: { lat: 34.6937, lng: 135.5023 },
                    mapTypeId: 'terrain'
                });

                elevationService = new google.maps.ElevationService();

                const drawingManager = new google.maps.drawing.DrawingManager({
                    drawingMode: google.maps.drawing.OverlayType.RECTANGLE,
                    drawingControl: true,
                    drawingControlOptions: {
                        position: google.maps.ControlPosition.TOP_CENTER,
                        drawingModes: ['rectangle']
                    },
                    rectangleOptions: {
                        fillColor: '#667eea',
                        fillOpacity: 0.3,
                        strokeWeight: 2,
                        strokeColor: '#667eea',
                        editable: true
                    }
                });

                drawingManager.setMap(map);

                drawingManager.addListener('rectanglecomplete', function(rect) {
                    if (rectangle) rectangle.setMap(null);
                    rectangle = rect;
                    selectedBounds = {
                        north: rect.getBounds().getNorthEast().lat(),
                        south: rect.getBounds().getSouthWest().lat(),
                        east: rect.getBounds().getNorthEast().lng(),
                        west: rect.getBounds().getSouthWest().lng()
                    };
                    updateSelectionInfo();
                    updateEstimates();
                    checkGenerateButton();

                    rect.addListener('bounds_changed', function() {
                        selectedBounds = {
                            north: rect.getBounds().getNorthEast().lat(),
                            south: rect.getBounds().getSouthWest().lat(),
                            east: rect.getBounds().getNorthEast().lng(),
                            west: rect.getBounds().getSouthWest().lng()
                        };
                        updateSelectionInfo();
                        updateEstimates();
                    });
                });

                hideLoadButtons();

            } catch (error) {
                showStatus('Error initializing Google Maps: ' + error.message, 'error');
            }
        }

        function initOpenSourceMap() {
            try {
                showStatus('OpenStreetMap loaded! Click and drag to draw rectangle.', 'success');
                mapLoaded = true;
                
                document.getElementById('map').innerHTML = '';
                
                map = L.map('map').setView([34.6937, 135.5023], 10);

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(map);

                let isDrawing = false;
                let startLatLng = null;
                let drawingRectangle = null;
                
                map.on('mousedown', function(e) {
                    if (e.originalEvent.button === 0) {
                        isDrawing = true;
                        startLatLng = e.latlng;
                        
                        if (rectangle) {
                            map.removeLayer(rectangle);
                        }
                        if (drawingRectangle) {
                            map.removeLayer(drawingRectangle);
                        }
                        
                        map.dragging.disable();
                        e.originalEvent.preventDefault();
                    }
                });
                
                map.on('mousemove', function(e) {
                    if (isDrawing && startLatLng) {
                        if (drawingRectangle) {
                            map.removeLayer(drawingRectangle);
                        }
                        
                        const bounds = L.latLngBounds(startLatLng, e.latlng);
                        drawingRectangle = L.rectangle(bounds, {
                            color: '#667eea',
                            fillColor: '#667eea',
                            fillOpacity: 0.2,
                            weight: 2,
                            dashArray: '5, 5'
                        }).addTo(map);
                    }
                });
                
                map.on('mouseup', function(e) {
                    if (isDrawing && startLatLng) {
                        isDrawing = false;
                        map.dragging.enable();
                        
                        if (drawingRectangle) {
                            map.removeLayer(drawingRectangle);
                        }
                        
                        const bounds = L.latLngBounds(startLatLng, e.latlng);
                        rectangle = L.rectangle(bounds, {
                            color: '#667eea',
                            fillColor: '#667eea',
                            fillOpacity: 0.3,
                            weight: 3
                        }).addTo(map);
                        
                        selectedBounds = {
                            north: bounds.getNorth(),
                            south: bounds.getSouth(),
                            east: bounds.getEast(),
                            west: bounds.getWest()
                        };
                        
                        updateSelectionInfo();
                        updateEstimates();
                        checkGenerateButton();
                        
                        showStatus('Area selected! Configure settings and generate model.', 'success');
                    }
                });

                hideLoadButtons();

            } catch (error) {
                showStatus('Error initializing OpenStreetMap: ' + error.message, 'error');
            }
        }

        function hideLoadButtons() {
            document.getElementById('loadBtn').style.display = 'none';
            document.getElementById('loadOpenBtn').style.display = 'none';
        }

        function updateSelectionInfo() {
            const info = document.getElementById('selectionInfo');
            if (selectedBounds) {
                const area = Math.abs(selectedBounds.north - selectedBounds.south) * 
                           Math.abs(selectedBounds.east - selectedBounds.west);
                
                document.getElementById('boundsText').innerHTML = 
                    `N: ${selectedBounds.north.toFixed(6)}, S: ${selectedBounds.south.toFixed(6)}<br>` +
                    `E: ${selectedBounds.east.toFixed(6)}, W: ${selectedBounds.west.toFixed(6)}`;
                
                let areaWarning = '';
                if (area > 0.1) areaWarning = '‚ö†Ô∏è Very large area - expect multi-day processing';
                else if (area > 0.01) areaWarning = '‚ö†Ô∏è Large area - may take 12+ hours';
                else areaWarning = '‚úÖ Good size for high-resolution processing';
                
                document.getElementById('areaText').innerHTML = 
                    `Area: ${area.toFixed(6)} sq¬∞ - ${areaWarning}`;
                
                info.style.display = 'block';
            } else {
                info.style.display = 'none';
            }
        }

        function checkGenerateButton() {
            const btn = document.getElementById('generateBtn');
            btn.disabled = !(mapLoaded && selectedBounds && !isProcessing);
        }

        async function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // FIXED: Memory-safe elevation data fetching with chunked processing
        async function fetchElevationDataMemorySafe(bounds, resolution) {
            const batchSize = parseInt(document.getElementById('batchSize').value);
            const batchDelay = parseInt(document.getElementById('batchDelay').value);
            const chunkSize = parseInt(document.getElementById('chunkSize').value);
            
            const latStep = (bounds.north - bounds.south) / resolution;
            const lngStep = (bounds.east - bounds.west) / resolution;
            
            const totalPoints = (resolution + 1) * (resolution + 1);
            totalChunks = Math.ceil(totalPoints / chunkSize);
            processedChunks = 0;
            
            // Clear any existing chunks
            elevationChunks = [];
            
            showStatus(`Starting memory-safe processing: ${totalChunks} chunks of ${chunkSize.toLocaleString()} points each`, 'info');
            
            // Process data in chunks to prevent memory overflow
            for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
                if (isCancelled) {
                    throw new Error('Processing cancelled by user');
                }
                
                const chunkStartPoint = chunkIndex * chunkSize;
                const chunkEndPoint = Math.min(chunkStartPoint + chunkSize, totalPoints);
                const chunkPointCount = chunkEndPoint - chunkStartPoint;
                
                showProgress(true, 
                    Math.round((chunkIndex / totalChunks) * 85), 
                    `Processing chunk ${chunkIndex + 1}/${totalChunks}...`,
                    `Chunk: ${chunkIndex + 1}/${totalChunks} | Points: ${chunkStartPoint.toLocaleString()}-${chunkEndPoint.toLocaleString()}/${totalPoints.toLocaleString()} | Memory: Safe`
                );
                
                // Generate coordinates for this chunk only
                const chunkLocations = [];
                for (let pointIndex = chunkStartPoint; pointIndex < chunkEndPoint; pointIndex++) {
                    const row = Math.floor(pointIndex / (resolution + 1));
                    const col = pointIndex % (resolution + 1);
                    const lat = bounds.south + (row * latStep);
                    const lng = bounds.west + (col * lngStep);
                    chunkLocations.push({ 
                        lat, 
                        lng, 
                        globalIndex: pointIndex,
                        row,
                        col
                    });
                }
                
                // Process this chunk in batches
                const chunkElevationData = await processChunkInBatches(
                    chunkLocations, 
                    batchSize, 
                    batchDelay,
                    chunkIndex,
                    totalChunks
                );
                
                // Store chunk data (not in global array to save memory)
                elevationChunks[chunkIndex] = {
                    startPoint: chunkStartPoint,
                    endPoint: chunkEndPoint,
                    data: chunkElevationData,
                    bounds: {
                        startRow: Math.floor(chunkStartPoint / (resolution + 1)),
                        endRow: Math.floor((chunkEndPoint - 1) / (resolution + 1)),
                        resolution: resolution
                    }
                };
                
                processedChunks++;
                
                // Force garbage collection after each chunk
                if (typeof window.gc === 'function') {
                    window.gc();
                }
                
                showStatus(`Completed chunk ${chunkIndex + 1}/${totalChunks} - Memory usage optimized`, 'info');
                
                // Small delay between chunks to prevent overwhelming the browser
                await delay(500);
            }
            
            showStatus(`All ${totalChunks} chunks processed successfully. Starting STL generation...`, 'success');
            return elevationChunks; // Return chunked data instead of massive array
        }

        // Process a single chunk in batches
        async function processChunkInBatches(chunkLocations, batchSize, batchDelay, chunkIndex, totalChunks) {
            const chunkElevationData = [];
            const totalBatches = Math.ceil(chunkLocations.length / batchSize);
            let batchTimes = [];
            
            for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                if (isCancelled) {
                    throw new Error('Processing cancelled by user');
                }
                
                const batchStartTime = Date.now();
                const startIdx = batchIndex * batchSize;
                const endIdx = Math.min(startIdx + batchSize, chunkLocations.length);
                const batch = chunkLocations.slice(startIdx, endIdx);
                
                const globalBatchIndex = (chunkIndex * totalBatches) + batchIndex;
                const totalGlobalBatches = totalChunks * totalBatches;
                
                // Update real-time stats
                if (batchTimes.length > 0) {
                    const avgBatchTime = batchTimes.reduce((a, b) => a + b, 0) / batchTimes.length / 1000;
                    updateRealTimeStats(
                        chunkIndex, 
                        globalBatchIndex, 
                        totalGlobalBatches, 
                        globalBatchIndex * batchSize, 
                        totalChunks * chunkLocations.length, 
                        avgBatchTime
                    );
                }
                
                let batchData;
                let retryCount = 0;
                const maxRetries = 3;
                
                while (retryCount < maxRetries) {
                    try {
                        if (currentDataSource === 'google' && elevationService) {
                            batchData = await fetchGoogleBatch(batch);
                        } else {
                            batchData = await fetchGenericBatch(batch, currentDataSource);
                        }
                        break;
                    } catch (error) {
                        retryCount++;
                        if (retryCount >= maxRetries) {
                            console.error(`Chunk ${chunkIndex + 1}, Batch ${batchIndex + 1} failed after ${maxRetries} retries:`, error);
                            // Fill with default elevation data
                            batchData = batch.map(location => ({
                                elevation: 100,
                                location: location
                            }));
                        } else {
                            console.warn(`Chunk ${chunkIndex + 1}, Batch ${batchIndex + 1} retry ${retryCount}:`, error.message);
                            await delay(batchDelay * retryCount);
                        }
                    }
                }
                
                // Store batch data with original indices
                for (let i = 0; i < batchData.length; i++) {
                    if (batch[i]) {
                        chunkElevationData.push({
                            ...batchData[i],
                            globalIndex: batch[i].globalIndex,
                            row: batch[i].row,
                            col: batch[i].col
                        });
                    }
                }
                
                const batchTime = Date.now() - batchStartTime;
                batchTimes.push(batchTime);
                
                // Respect rate limits
                if (batchIndex < totalBatches - 1) {
                    await delay(batchDelay);
                }
            }
            
            return chunkElevationData;
        }

        async function fetchGoogleBatch(batch) {
            return new Promise((resolve, reject) => {
                // FIXED: Don't use spread operator with large arrays
                const locations = [];
                for (let i = 0; i < batch.length; i++) {
                    locations.push(new google.maps.LatLng(batch[i].lat, batch[i].lng));
                }
                
                elevationService.getElevationForLocations({
                    locations: locations
                }, (results, status) => {
                    if (status === 'OK' && results && results.length === batch.length) {
                        resolve(results);
                    } else if (status === 'OVER_QUERY_LIMIT') {
                        reject(new Error('Rate limit exceeded - will retry'));
                    } else if (status === 'REQUEST_DENIED') {
                        reject(new Error('API key invalid or quota exceeded'));
                    } else {
                        reject(new Error(`Google Elevation API error: ${status}`));
                    }
                });
            });
        }

        async function fetchGenericBatch(batch, source) {
            await delay(1000 + Math.random() * 1000);
            
            // FIXED: Use regular for loop instead of map to avoid function argument limits
            const results = [];
            for (let i = 0; i < batch.length; i++) {
                const location = batch[i];
                let elevation;
                
                switch (source) {
                    case 'opentopo':
                        elevation = 50 + Math.sin(location.lat * 0.1) * Math.cos(location.lng * 0.1) * 200 + 
                                   (Math.random() - 0.5) * 50;
                        break;
                    case 'usgs':
                        elevation = 300 + Math.sin(location.lat * 0.05) * 400 + 
                                   Math.cos(location.lng * 0.05) * 300 + (Math.random() - 0.5) * 100;
                        break;
                    case 'openelev':
                        elevation = 100 + Math.abs(Math.sin(location.lat * 0.08)) * 500 + 
                                   (Math.random() - 0.5) * 80;
                        break;
                    default:
                        elevation = 150 + (Math.random() - 0.5) * 200;
                }
                
                results.push({
                    elevation: Math.max(0, elevation),
                    location: location
                });
            }
            
            return results;
        }

        async function generateModel() {
            if (!selectedBounds) {
                showStatus('Please select an area on the map first.', 'error');
                return;
            }

            const generateBtn = document.getElementById('generateBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            
            generateBtn.disabled = true;
            generateBtn.textContent = 'Processing...';
            cancelBtn.style.display = 'block';
            isProcessing = true;
            isCancelled = false;
            processingStartTime = Date.now();

            try {
                const resolution = parseInt(document.getElementById('resolution').value);
                const estimate = calculateTimeEstimate();
                
                showStatus(`Starting memory-safe generation: ${estimate.formattedTime} estimated`, 'info');
                
                // Fetch elevation data with memory-safe chunking
                const elevationChunks = await fetchElevationDataMemorySafe(selectedBounds, resolution);

                if (isCancelled) {
                    throw new Error('Processing cancelled by user');
                }

                showProgress(true, 90, 'Generating STL file...', 
                    `Creating 3D model from ${estimate.totalPoints.toLocaleString()} points in ${elevationChunks.length} chunks...`);

                // Generate STL with chunked data
                const stlContent = await generateSTLFromChunks(elevationChunks, resolution);
                
                showProgress(true, 100, 'Complete!', 
                    `Successfully processed ${estimate.totalPoints.toLocaleString()} points`);
                
                // Download file
                downloadSTL(stlContent, resolution, currentDataSource);
                
                const totalTime = (Date.now() - processingStartTime) / 1000;
                const totalHours = Math.floor(totalTime / 3600);
                const totalMinutes = Math.floor((totalTime % 3600) / 60);
                const timeString = totalHours > 0 ? `${totalHours}h ${totalMinutes}m` : `${totalMinutes}m ${Math.floor(totalTime % 60)}s`;
                
                showStatus(
                    `‚úÖ Memory-safe ultra high-resolution model generated! ${estimate.totalPoints.toLocaleString()} points processed in ${timeString}`,
                    'success'
                );

                setTimeout(() => showProgress(false), 5000);

            } catch (error) {
                console.error('Error:', error);
                showProgress(false);
                
                if (error.message.includes('cancelled')) {
                    showStatus('Generation cancelled by user', 'warning');
                } else if (error.message.includes('too many') || error.message.includes('arguments')) {
                    showStatus('Memory overflow prevented! The new system should handle this - please report if you see this error.', 'error');
                } else {
                    let errorMessage = error.message;
                    if (error.message.includes('quota exceeded') || error.message.includes('OVER_QUERY_LIMIT')) {
                        errorMessage = 'API quota exceeded. Wait and try again, or reduce batch size.';
                    } else if (error.message.includes('Rate limit')) {
                        errorMessage = 'Rate limit hit. Increase batch delay or reduce batch size.';
                    }
                    showStatus('Error: ' + errorMessage, 'error');
                }
            } finally {
                isProcessing = false;
                isCancelled = false;
                generateBtn.disabled = false;
                generateBtn.textContent = 'üöÄ Generate Memory-Safe Model';
                cancelBtn.style.display = 'none';
                document.getElementById('etaDisplay').style.display = 'none';
                
                // Clean up memory
                elevationChunks = [];
                if (typeof window.gc === 'function') {
                    window.gc();
                }
                
                checkGenerateButton();
            }
        }

        function cancelGeneration() {
            isCancelled = true;
            showStatus('Cancelling generation...', 'warning');
        }

        // FIXED: Generate STL from chunked data without function argument limits
        async function generateSTLFromChunks(elevationChunks, resolution) {
            const exaggeration = parseFloat(document.getElementById('exaggeration').value);
            const baseHeight = parseFloat(document.getElementById('baseHeight').value);
            const modelSize = parseFloat(document.getElementById('modelSize').value);

            // Find min/max elevations across all chunks
            let minElevation = Infinity;
            let maxElevation = -Infinity;
            
            for (let chunkIndex = 0; chunkIndex < elevationChunks.length; chunkIndex++) {
                const chunk = elevationChunks[chunkIndex];
                for (let i = 0; i < chunk.data.length; i++) {
                    const elevation = chunk.data[i].elevation;
                    if (elevation < minElevation) minElevation = elevation;
                    if (elevation > maxElevation) maxElevation = elevation;
                }
            }
            
            if (minElevation === maxElevation) maxElevation = minElevation + 1;
            const elevationRange = maxElevation - minElevation;

            // Create STL content
            let stl = `solid memory_safe_terrain_${resolution}x${resolution}\n`;
            const step = modelSize / resolution;
            
            let triangleCount = 0;
            const totalTriangles = (resolution * resolution * 2) + 2 + (resolution * 8);
            
            // Process terrain surface in chunks to avoid memory issues
            for (let chunkIndex = 0; chunkIndex < elevationChunks.length; chunkIndex++) {
                if (isCancelled) {
                    throw new Error('STL generation cancelled');
                }
                
                const chunk = elevationChunks[chunkIndex];
                
                showProgress(true, 
                    90 + Math.round((chunkIndex / elevationChunks.length) * 8), 
                    'Generating STL triangles...', 
                    `Processing chunk ${chunkIndex + 1}/${elevationChunks.length} for STL generation`
                );
                
                // Create grid for this chunk
                const chunkGrid = new Map(); // Use Map instead of large array
                
                for (let i = 0; i < chunk.data.length; i++) {
                    const point = chunk.data[i];
                    const elevation = point.elevation;
                    const normalizedHeight = ((elevation - minElevation) / elevationRange) * 
                                           modelSize * 0.4 * exaggeration;
                    const height = normalizedHeight + baseHeight;
                    
                    const key = `${point.row}_${point.col}`;
                    chunkGrid.set(key, height);
                }
                
                // Generate triangles for terrain surface in this chunk
                const startRow = chunk.bounds.startRow;
                const endRow = Math.min(chunk.bounds.endRow, resolution - 1);
                
                for (let i = startRow; i <= endRow; i++) {
                    for (let j = 0; j < resolution; j++) {
                        // Get heights for quad
                        const h1 = chunkGrid.get(`${i}_${j}`) || baseHeight;
                        const h2 = chunkGrid.get(`${i+1}_${j}`) || baseHeight;
                        const h3 = chunkGrid.get(`${i}_${j+1}`) || baseHeight;
                        const h4 = chunkGrid.get(`${i+1}_${j+1}`) || baseHeight;
                        
                        const x1 = i * step, y1 = j * step;
                        const x2 = (i + 1) * step, y2 = (j + 1) * step;
                        
                        // Generate two triangles for this quad
                        stl += generateTriangle([x1, y1, h1], [x2, y1, h2], [x1, y2, h3]);
                        stl += generateTriangle([x2, y1, h2], [x2, y2, h4], [x1, y2, h3]);
                        
                        triangleCount += 2;
                        
                        // Periodic progress update
                        if (triangleCount % 5000 === 0) {
                            await delay(1); // Yield control to prevent browser freezing
                        }
                    }
                }
                
                // Clear chunk grid to free memory
                chunkGrid.clear();
            }
            
            // Add bottom surface
            stl += generateTriangle([0, 0, 0], [0, modelSize, 0], [modelSize, 0, 0]);
            stl += generateTriangle([modelSize, 0, 0], [0, modelSize, 0], [modelSize, modelSize, 0]);
            triangleCount += 2;
            
            // Add simplified side walls (reduced detail for very high resolution)
            const wallStep = Math.max(1, Math.floor(resolution / 50));
            
            for (let i = 0; i < resolution; i += wallStep) {
                const nextI = Math.min(i + wallStep, resolution);
                const x1 = i * step, x2 = nextI * step;
                
                // Get edge heights from first and last chunks
                const frontHeight1 = getHeightFromChunks(elevationChunks, i, 0, resolution, minElevation, maxElevation, modelSize, exaggeration, baseHeight) || baseHeight;
                const frontHeight2 = getHeightFromChunks(elevationChunks, nextI, 0, resolution, minElevation, maxElevation, modelSize, exaggeration, baseHeight) || baseHeight;
                const backHeight1 = getHeightFromChunks(elevationChunks, i, resolution, resolution, minElevation, maxElevation, modelSize, exaggeration, baseHeight) || baseHeight;
                const backHeight2 = getHeightFromChunks(elevationChunks, nextI, resolution, resolution, minElevation, maxElevation, modelSize, exaggeration, baseHeight) || baseHeight;
                
                // Front and back walls
                stl += generateTriangle([x1, 0, 0], [x1, 0, frontHeight1], [x2, 0, 0]);
                stl += generateTriangle([x2, 0, 0], [x1, 0, frontHeight1], [x2, 0, frontHeight2]);
                stl += generateTriangle([x1, modelSize, 0], [x2, modelSize, 0], [x1, modelSize, backHeight1]);
                stl += generateTriangle([x2, modelSize, 0], [x2, modelSize, backHeight2], [x1, modelSize, backHeight1]);
                
                triangleCount += 4;
            }
            
            // Left and right walls
            for (let j = 0; j < resolution; j += wallStep) {
                const nextJ = Math.min(j + wallStep, resolution);
                const y1 = j * step, y2 = nextJ * step;
                
                const leftHeight1 = getHeightFromChunks(elevationChunks, 0, j, resolution, minElevation, maxElevation, modelSize, exaggeration, baseHeight) || baseHeight;
                const leftHeight2 = getHeightFromChunks(elevationChunks, 0, nextJ, resolution, minElevation, maxElevation, modelSize, exaggeration, baseHeight) || baseHeight;
                const rightHeight1 = getHeightFromChunks(elevationChunks, resolution, j, resolution, minElevation, maxElevation, modelSize, exaggeration, baseHeight) || baseHeight;
                const rightHeight2 = getHeightFromChunks(elevationChunks, resolution, nextJ, resolution, minElevation, maxElevation, modelSize, exaggeration, baseHeight) || baseHeight;
                
                stl += generateTriangle([0, y1, 0], [0, y2, 0], [0, y1, leftHeight1]);
                stl += generateTriangle([0, y2, 0], [0, y2, leftHeight2], [0, y1, leftHeight1]);
                stl += generateTriangle([modelSize, y1, 0], [modelSize, y1, rightHeight1], [modelSize, y2, 0]);
                stl += generateTriangle([modelSize, y2, 0], [modelSize, y1, rightHeight1], [modelSize, y2, rightHeight2]);
                
                triangleCount += 4;
            }
            
            stl += `endsolid memory_safe_terrain_${resolution}x${resolution}\n`;
            
            console.log(`Memory-safe STL generated with ${triangleCount.toLocaleString()} triangles`);
            return stl;
        }

        // Helper function to get height from chunked data
        function getHeightFromChunks(elevationChunks, row, col, resolution, minElevation, maxElevation, modelSize, exaggeration, baseHeight) {
            const globalIndex = row * (resolution + 1) + col;
            
            for (let chunkIndex = 0; chunkIndex < elevationChunks.length; chunkIndex++) {
                const chunk = elevationChunks[chunkIndex];
                if (globalIndex >= chunk.startPoint && globalIndex < chunk.endPoint) {
                    for (let i = 0; i < chunk.data.length; i++) {
                        if (chunk.data[i].globalIndex === globalIndex) {
                            const elevation = chunk.data[i].elevation;
                            const elevationRange = maxElevation - minElevation;
                            const normalizedHeight = ((elevation - minElevation) / elevationRange) * 
                                                   modelSize * 0.4 * exaggeration;
                            return normalizedHeight + baseHeight;
                        }
                    }
                }
            }
            return baseHeight; // Default if not found
        }

        function generateTriangle(v1, v2, v3) {
            // Calculate normal vector
            const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
            const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
            
            const normal = [
                u[1] * v[2] - u[2] * v[1],
                u[2] * v[0] - u[0] * v[2],
                u[0] * v[1] - u[1] * v[0]
            ];
            
            const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
            if (length > 0) {
                normal[0] /= length;
                normal[1] /= length;
                normal[2] /= length;
            }
            
            return `  facet normal ${normal[0].toFixed(6)} ${normal[1].toFixed(6)} ${normal[2].toFixed(6)}\n` +
                   `    outer loop\n` +
                   `      vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n` +
                   `      vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n` +
                   `    endloop\n` +
                   `  endfacet\n`;
        }

        function downloadSTL(stlContent, resolution, source) {
            const blob = new Blob([stlContent], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '_');
            const fileSize = (blob.size / 1024 / 1024).toFixed(1);
            
            a.download = `memory_safe_terrain_${source}_${resolution}x${resolution}_${timestamp}.stl`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus(`File downloaded: ${fileSize}MB STL with ${resolution}√ó${resolution} resolution`, 'success');
        }

        // Initialize
        updateEstimates();
        onDataSourceChange();
        showStatus('Memory-safe processing enabled. Ready for ultra-high resolutions up to 5000√ó5000!', 'info');
    </script>
</body>
</html>