<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hybrid Terrain Generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .top-bar {
            background: rgba(255,255,255,0.1);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
        }
        
        .logo {
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .processing-mode {
            background: white;
            border-radius: 6px;
            padding: 8px 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .processing-mode select {
            border: none;
            background: none;
            font-size: 14px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
            outline: none;
        }
        
        .container {
            max-width: 1400px;
            margin: 20px auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .header h1 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
        }
        
        .map-container {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            overflow: hidden;
        }
        
        #map {
            width: 100%;
            height: 600px;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #dee2e6;
            max-height: 900px;
            overflow-y: auto;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        
        .control-group input,
        .control-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        .button {
            width: 100%;
            padding: 12px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px 0;
            box-sizing: border-box;
        }
        
        .button:hover {
            background: #5a6fd8;
        }
        
        .button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .button.server-mode {
            background: #28a745;
        }
        
        .button.server-mode:hover {
            background: #218838;
        }
        
        .button.cancel {
            background: #dc3545;
        }
        
        .button.cancel:hover {
            background: #c82333;
        }
        
        .status {
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: 500;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .progress-container {
            display: none;
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 2px solid #667eea;
        }
        
        .progress-container.active {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 15px;
            background: #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .server-progress-fill {
            background: linear-gradient(90deg, #28a745, #20c997);
        }
        
        .progress-details {
            font-size: 0.9rem;
            color: #555;
            margin-top: 10px;
        }
        
        .processing-mode-info {
            background: #e8f5e8;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .server-mode-info {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            color: #155724;
        }
        
        .client-mode-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            color: #0c5460;
        }
        
        .info-box {
            background: #f0f8ff;
            border: 1px solid #b3d9ff;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .selection-info {
            background: #e8f5e8;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }
        
        .range-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .range-group input[type="range"] {
            flex: 1;
        }
        
        .range-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }
        
        .api-key-group {
            display: none;
        }
        
        .api-key-field {
            margin-bottom: 15px;
        }
        
        .api-key-field label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        
        .api-key-group.active {
            display: block;
        }
        
        .time-estimate {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.9rem;
            color: #856404;
        }
        
        .job-tracker {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }
        
        .job-tracker.active {
            display: block;
        }
        
        .job-status {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .download-links {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }
        
        .download-links.active {
            display: block;
        }
        
        .download-link {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            text-decoration: none;
            margin: 5px;
            font-size: 0.9rem;
        }
        
        .download-link:hover {
            background: #218838;
            color: white;
            text-decoration: none;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            #map {
                height: 400px;
            }
            
            .top-bar {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="logo">üèîÔ∏è Hybrid Terrain Generator</div>
        <div class="processing-mode">
            <select id="processingMode" onchange="onProcessingModeChange()">
                <option value="client">Client-Side (Fast, Keep Browser Open)</option>
                <option value="server">Server-Side (Slow, Laptop Can Sleep)</option>
            </select>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>üåç Hybrid Terrain Generator</h1>
            <p>Choose client-side for quick jobs or server-side for overnight processing</p>
        </div>

        <div class="main-content">
            <div class="map-container">
                <div id="map"></div>
            </div>

            <div class="controls">
                <div id="processingModeInfo" class="processing-mode-info">
                    <strong>üñ•Ô∏è Client-Side Processing</strong><br>
                    Fast processing, but keep browser tab open. Good for resolutions up to 1000√ó1000.
                </div>

                <div id="apiKeyGroup" class="control-group api-key-group active">
                    <div id="googleApiKey" class="api-key-field">
                        <label for="googleKey">Google Maps API Key:</label>
                        <input type="password" id="googleKey" placeholder="Enter your Google Maps API key">
                    </div>
                    
                    <button class="button" onclick="loadMap()" id="loadBtn">Load Map</button>
                </div>

                <div id="openSourceGroup" class="control-group api-key-group">
                    <div class="info-box">
                        <strong>üÜì Open Source Data</strong><br>
                        No API key required! Uses OpenStreetMap for display.
                    </div>
                    <button class="button" onclick="loadOpenSourceMap()" id="loadOpenBtn">Load Open Source Map</button>
                </div>

                <div class="selection-info" id="selectionInfo">
                    <strong>üìç Selected Area:</strong><br>
                    <span id="boundsText"></span><br>
                    <span id="areaText"></span>
                </div>

                <div class="control-group">
                    <label for="resolution">Resolution:</label>
                    <select id="resolution" onchange="updateEstimates()">
                        <option value="200">200√ó200 (40K points) - 15-30 min</option>
                        <option value="500" selected>500√ó500 (250K points) - 1-2 hours</option>
                        <option value="1000">1000√ó1000 (1M points) - 3-6 hours</option>
                        <option value="1500">1500√ó1500 (2.25M points) - 6-12 hours</option>
                        <option value="2000">2000√ó2000 (4M points) - 12-24 hours</option>
                        <option value="3000">3000√ó3000 (9M points) - 1-3 days</option>
                        <option value="5000">5000√ó5000 (25M points) - 3-7 days</option>
                    </select>
                </div>

                <div id="timeEstimate" class="time-estimate">
                    <strong>‚è±Ô∏è Estimated Time:</strong><br>
                    <span id="estimateText">Select resolution for estimate</span>
                </div>

                <div class="control-group">
                    <label for="batchSize">Batch Size:</label>
                    <select id="batchSize" onchange="updateEstimates()">
                        <option value="50">50 points - Ultra-safe</option>
                        <option value="100" selected>100 points - Balanced</option>
                        <option value="200">200 points - Faster</option>
                        <option value="300">300 points - Maximum</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="batchDelay">Delay Between Batches (ms):</label>
                    <select id="batchDelay" onchange="updateEstimates()">
                        <option value="500">500ms - Fast</option>
                        <option value="1000" selected>1000ms - Safe</option>
                        <option value="1500">1500ms - Conservative</option>
                        <option value="2000">2000ms - Ultra-safe</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="exaggeration">Terrain Exaggeration: <span id="exagValue">2.0√ó</span></label>
                    <div class="range-group">
                        <input type="range" id="exaggeration" min="0.5" max="5" step="0.1" value="2" 
                               oninput="document.getElementById('exagValue').textContent = this.value + '√ó'">
                    </div>
                </div>

                <div class="control-group">
                    <label for="baseHeight">Base Height (mm):</label>
                    <input type="number" id="baseHeight" value="5" min="1" max="20">
                </div>

                <div class="control-group">
                    <label for="modelSize">Model Size (mm):</label>
                    <input type="number" id="modelSize" value="150" min="50" max="500">
                </div>

                <div class="progress-container" id="progressContainer">
                    <div><strong id="progressTitle">Processing...</strong></div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div id="progressText">Initializing...</div>
                    <div class="progress-details" id="progressDetails">
                        Ready to process...
                    </div>
                </div>

                <div class="job-tracker" id="jobTracker">
                    <div class="job-status" id="jobStatus">Job Status: Queued</div>
                    <div id="jobDetails">Job ID: <span id="jobId"></span></div>
                    <div id="jobProgress">Progress: <span id="jobProgressText">0%</span></div>
                    <div id="jobStep">Step: <span id="jobStepText">Initializing...</span></div>
                    <button class="button cancel" onclick="cancelServerJob()" id="cancelJobBtn">Cancel Server Job</button>
                </div>

                <div class="download-links" id="downloadLinks">
                    <strong>üì• Download Your Model:</strong><br>
                    <div id="downloadLinksContent"></div>
                </div>

                <button class="button" id="generateBtn" onclick="generateModel()" disabled>
                    üöÄ Generate Terrain Model
                </button>

                <button class="button cancel" id="cancelBtn" onclick="cancelGeneration()" style="display: none;">
                    ‚ùå Cancel Generation
                </button>

                <div id="status"></div>
            </div>
        </div>
    </div>

    <script>
        let map, rectangle, selectedBounds = null;
        let mapLoaded = false;
        let isProcessing = false;
        let isCancelled = false;
        let elevationService = null;
        let currentProcessingMode = 'client';
        let serverJobId = null;
        let jobStatusInterval = null;

        function onProcessingModeChange() {
            const mode = document.getElementById('processingMode').value;
            currentProcessingMode = mode;
            
            const modeInfo = document.getElementById('processingModeInfo');
            const generateBtn = document.getElementById('generateBtn');
            
            if (mode === 'server') {
                modeInfo.className = 'server-mode-info';
                modeInfo.innerHTML = `
                    <strong>‚òÅÔ∏è Server-Side Processing</strong><br>
                    Processing happens on the server. Your laptop can sleep! Files automatically uploaded to cloud storage.
                `;
                generateBtn.className = 'button server-mode';
                generateBtn.textContent = '‚òÅÔ∏è Start Server-Side Job';
            } else {
                modeInfo.className = 'client-mode-info';
                modeInfo.innerHTML = `
                    <strong>üñ•Ô∏è Client-Side Processing</strong><br>
                    Fast processing in your browser. Keep this tab open during processing.
                `;
                generateBtn.className = 'button';
                generateBtn.textContent = 'üöÄ Generate Terrain Model';
            }
            
            updateEstimates();
            checkGenerateButton();
            hideJobTracker();
        }

        function updateEstimates() {
            const resolution = parseInt(document.getElementById('resolution').value);
            const batchSize = parseInt(document.getElementById('batchSize').value);
            const batchDelay = parseInt(document.getElementById('batchDelay').value);
            
            const totalPoints = (resolution + 1) * (resolution + 1);
            const totalBatches = Math.ceil(totalPoints / batchSize);
            
            // Base processing time
            const processingTimePerBatch = (batchDelay / 1000) + 2;
            const baseProcessingTime = totalBatches * processingTimePerBatch;
            
            // Adjust for processing mode
            let adjustedTime;
            if (currentProcessingMode === 'server') {
                adjustedTime = baseProcessingTime * 0.8; // Server is more efficient
            } else {
                adjustedTime = baseProcessingTime;
            }
            
            const days = Math.floor(adjustedTime / 86400);
            const hours = Math.floor((adjustedTime % 86400) / 3600);
            const minutes = Math.floor((adjustedTime % 3600) / 60);
            
            let formattedTime;
            if (days > 0) {
                formattedTime = `${days}d ${hours}h ${minutes}m`;
            } else if (hours > 0) {
                formattedTime = `${hours}h ${minutes}m`;
            } else {
                formattedTime = `${minutes}m`;
            }
            
            const modeText = currentProcessingMode === 'server' ? 
                'Server-side (laptop can sleep)' : 
                'Client-side (keep browser open)';
            
            document.getElementById('estimateText').innerHTML = `
                <strong>${formattedTime}</strong> for ${totalPoints.toLocaleString()} points<br>
                <small>${modeText} - ${totalBatches.toLocaleString()} batches</small>
            `;
        }

        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.className = `status ${type}`;
            status.textContent = message;
        }

        function showProgress(show, progress = 0, text = '', details = '') {
            const container = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            
            if (show) {
                container.classList.add('active');
                progressFill.style.width = progress + '%';
                progressFill.className = currentProcessingMode === 'server' ? 
                    'progress-fill server-progress-fill' : 'progress-fill';
                document.getElementById('progressText').textContent = text;
                if (details) {
                    document.getElementById('progressDetails').textContent = details;
                }
            } else {
                container.classList.remove('active');
            }
        }

        function showJobTracker(jobId) {
            const tracker = document.getElementById('jobTracker');
            document.getElementById('jobId').textContent = jobId;
            tracker.classList.add('active');
            
            // Start polling job status
            if (jobStatusInterval) {
                clearInterval(jobStatusInterval);
            }
            
            jobStatusInterval = setInterval(() => {
                checkJobStatus(jobId);
            }, 5000); // Check every 5 seconds
        }

        function hideJobTracker() {
            const tracker = document.getElementById('jobTracker');
            tracker.classList.remove('active');
            
            if (jobStatusInterval) {
                clearInterval(jobStatusInterval);
                jobStatusInterval = null;
            }
        }

        async function checkJobStatus(jobId) {
            try {
                const response = await fetch(`/api/job/${jobId}`);
                if (!response.ok) {
                    throw new Error('Job not found');
                }
                
                const job = await response.json();
                
                document.getElementById('jobStatus').textContent = `Job Status: ${job.status}`;
                document.getElementById('jobProgressText').textContent = `${job.progress}%`;
                document.getElementById('jobStepText').textContent = job.currentStep;
                
                showProgress(true, job.progress, job.currentStep, 
                    `Server job: ${job.status} - ${job.progress}%`);
                
                if (job.status === 'completed') {
                    clearInterval(jobStatusInterval);
                    hideJobTracker();
                    showDownloadLinks(job);
                    showStatus(`‚úÖ Server job completed! File size: ${job.fileSize}`, 'success');
                } else if (job.status === 'failed') {
                    clearInterval(jobStatusInterval);
                    hideJobTracker();
                    showStatus(`‚ùå Server job failed: ${job.error}`, 'error');
                } else if (job.status === 'cancelled') {
                    clearInterval(jobStatusInterval);
                    hideJobTracker();
                    showStatus('Server job cancelled', 'warning');
                }
                
            } catch (error) {
                console.error('Error checking job status:', error);
            }
        }

        function showDownloadLinks(job) {
            const linksContainer = document.getElementById('downloadLinks');
            const linksContent = document.getElementById('downloadLinksContent');
            
            let linksHtml = '';
            for (const result of job.uploadResults) {
                if (result.success) {
                    linksHtml += `<a href="${result.downloadLink}" class="download-link" target="_blank">
                        üì• ${result.service}
                    </a>`;
                }
            }
            
            linksContent.innerHTML = linksHtml;
            linksContainer.classList.add('active');
        }

        async function cancelServerJob() {
            if (!serverJobId) return;
            
            try {
                const response = await fetch(`/api/job/${serverJobId}/cancel`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    showStatus('Server job cancellation requested', 'warning');
                } else {
                    showStatus('Failed to cancel server job', 'error');
                }
            } catch (error) {
                showStatus('Error cancelling server job: ' + error.message, 'error');
            }
        }

        function loadMap() {
            const apiKey = document.getElementById('googleKey').value.trim();
            
            if (!apiKey) {
                showStatus('Please enter your Google Maps API key.', 'error');
                return;
            }

            showStatus('Loading Google Maps...', 'info');
            
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=drawing&callback=initGoogleMap`;
            script.onerror = () => showStatus('Failed to load Google Maps. Check your API key.', 'error');
            
            window.initGoogleMap = initGoogleMap;
            document.head.appendChild(script);
        }

        function loadOpenSourceMap() {
            showStatus('Loading OpenStreetMap...', 'info');
            
            if (!window.L) {
                const leafletCSS = document.createElement('link');
                leafletCSS.rel = 'stylesheet';
                leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                document.head.appendChild(leafletCSS);
                
                const leafletJS = document.createElement('script');
                leafletJS.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                leafletJS.onload = initOpenSourceMap;
                document.head.appendChild(leafletJS);
            } else {
                initOpenSourceMap();
            }
        }

        function initGoogleMap() {
            try {
                showStatus('Google Maps loaded! Draw a rectangle to select terrain area.', 'success');
                mapLoaded = true;
                
                map = new google.maps.Map(document.getElementById('map'), {
                    zoom: 10,
                    center: { lat: 34.6937, lng: 135.5023 },
                    mapTypeId: 'terrain'
                });

                elevationService = new google.maps.ElevationService();

                const drawingManager = new google.maps.drawing.DrawingManager({
                    drawingMode: google.maps.drawing.OverlayType.RECTANGLE,
                    drawingControl: true,
                    drawingControlOptions: {
                        position: google.maps.ControlPosition.TOP_CENTER,
                        drawingModes: ['rectangle']
                    },
                    rectangleOptions: {
                        fillColor: '#667eea',
                        fillOpacity: 0.3,
                        strokeWeight: 2,
                        strokeColor: '#667eea',
                        editable: true
                    }
                });

                drawingManager.setMap(map);

                drawingManager.addListener('rectanglecomplete', function(rect) {
                    if (rectangle) rectangle.setMap(null);
                    rectangle = rect;
                    selectedBounds = {
                        north: rect.getBounds().getNorthEast().lat(),
                        south: rect.getBounds().getSouthWest().lat(),
                        east: rect.getBounds().getNorthEast().lng(),
                        west: rect.getBounds().getSouthWest().lng()
                    };
                    updateSelectionInfo();
                    updateEstimates();
                    checkGenerateButton();

                    rect.addListener('bounds_changed', function() {
                        selectedBounds = {
                            north: rect.getBounds().getNorthEast().lat(),
                            south: rect.getBounds().getSouthWest().lat(),
                            east: rect.getBounds().getNorthEast().lng(),
                            west: rect.getBounds().getSouthWest().lng()
                        };
                        updateSelectionInfo();
                        updateEstimates();
                    });
                });

                hideLoadButtons();

            } catch (error) {
                showStatus('Error initializing Google Maps: ' + error.message, 'error');
            }
        }

        function initOpenSourceMap() {
            try {
                showStatus('OpenStreetMap loaded! Click and drag to draw rectangle.', 'success');
                mapLoaded = true;
                
                document.getElementById('map').innerHTML = '';
                
                map = L.map('map').setView([34.6937, 135.5023], 10);

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(map);

                let isDrawing = false;
                let startLatLng = null;
                let drawingRectangle = null;
                
                map.on('mousedown', function(e) {
                    if (e.originalEvent.button === 0) {
                        isDrawing = true;
                        startLatLng = e.latlng;
                        
                        if (rectangle) {
                            map.removeLayer(rectangle);
                        }
                        if (drawingRectangle) {
                            map.removeLayer(drawingRectangle);
                        }
                        
                        map.dragging.disable();
                        e.originalEvent.preventDefault();
                    }
                });
                
                map.on('mousemove', function(e) {
                    if (isDrawing && startLatLng) {
                        if (drawingRectangle) {
                            map.removeLayer(drawingRectangle);
                        }
                        
                        const bounds = L.latLngBounds(startLatLng, e.latlng);
                        drawingRectangle = L.rectangle(bounds, {
                            color: '#667eea',
                            fillColor: '#667eea',
                            fillOpacity: 0.2,
                            weight: 2,
                            dashArray: '5, 5'
                        }).addTo(map);
                    }
                });
                
                map.on('mouseup', function(e) {
                    if (isDrawing && startLatLng) {
                        isDrawing = false;
                        map.dragging.enable();
                        
                        if (drawingRectangle) {
                            map.removeLayer(drawingRectangle);
                        }
                        
                        const bounds = L.latLngBounds(startLatLng, e.latlng);
                        rectangle = L.rectangle(bounds, {
                            color: '#667eea',
                            fillColor: '#667eea',
                            fillOpacity: 0.3,
                            weight: 3
                        }).addTo(map);
                        
                        selectedBounds = {
                            north: bounds.getNorth(),
                            south: bounds.getSouth(),
                            east: bounds.getEast(),
                            west: bounds.getWest()
                        };
                        
                        updateSelectionInfo();
                        updateEstimates();
                        checkGenerateButton();
                        
                        showStatus('Area selected! Configure settings and generate model.', 'success');
                    }
                });

                hideLoadButtons();

            } catch (error) {
                showStatus('Error initializing OpenStreetMap: ' + error.message, 'error');
            }
        }

        function hideLoadButtons() {
            document.getElementById('loadBtn').style.display = 'none';
            document.getElementById('loadOpenBtn').style.display = 'none';
        }

        function updateSelectionInfo() {
            const info = document.getElementById('selectionInfo');
            if (selectedBounds) {
                const area = Math.abs(selectedBounds.north - selectedBounds.south) * 
                           Math.abs(selectedBounds.east - selectedBounds.west);
                
                document.getElementById('boundsText').innerHTML = 
                    `N: ${selectedBounds.north.toFixed(6)}, S: ${selectedBounds.south.toFixed(6)}<br>` +
                    `E: ${selectedBounds.east.toFixed(6)}, W: ${selectedBounds.west.toFixed(6)}`;
                
                let areaWarning = '';
                if (area > 0.1) areaWarning = '‚ö†Ô∏è Very large area - use server-side processing';
                else if (area > 0.01) areaWarning = '‚ö†Ô∏è Large area - consider server-side processing';
                else areaWarning = '‚úÖ Good size for both processing modes';
                
                document.getElementById('areaText').innerHTML = 
                    `Area: ${area.toFixed(6)} sq¬∞ - ${areaWarning}`;
                
                info.style.display = 'block';
            } else {
                info.style.display = 'none';
            }
        }

        function checkGenerateButton() {
            const btn = document.getElementById('generateBtn');
            btn.disabled = !(mapLoaded && selectedBounds && !isProcessing);
        }

        async function generateModel() {
            if (!selectedBounds) {
                showStatus('Please select an area on the map first.', 'error');
                return;
            }

            if (currentProcessingMode === 'server') {
                return startServerSideJob();
            } else {
                return startClientSideProcessing();
            }
        }

        async function startServerSideJob() {
            const generateBtn = document.getElementById('generateBtn');
            generateBtn.disabled = true;
            isProcessing = true;

            try {
                const jobData = {
                    bounds: selectedBounds,
                    resolution: parseInt(document.getElementById('resolution').value),
                    dataSource: 'google',
                    apiKey: document.getElementById('googleKey').value.trim(),
                    batchSize: parseInt(document.getElementById('batchSize').value),
                    batchDelay: parseInt(document.getElementById('batchDelay').value),
                    exaggeration: parseFloat(document.getElementById('exaggeration').value),
                    baseHeight: parseFloat(document.getElementById('baseHeight').value),
                    modelSize: parseFloat(document.getElementById('modelSize').value)
                };

                showStatus('Starting server-side job...', 'info');

                const response = await fetch('/api/server-job', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(jobData)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to start server job');
                }

                const result = await response.json();
                serverJobId = result.jobId;

                showStatus(`‚úÖ Server job started! Job ID: ${result.jobId}. Your laptop can now sleep.`, 'success');
                showJobTracker(result.jobId);

            } catch (error) {
                showStatus('Error starting server job: ' + error.message, 'error');
            } finally {
                isProcessing = false;
                generateBtn.disabled = false;
                checkGenerateButton();
            }
        }

        async function startClientSideProcessing() {
            const generateBtn = document.getElementById('generateBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            
            generateBtn.disabled = true;
            cancelBtn.style.display = 'block';
            isProcessing = true;
            isCancelled = false;

            try {
                const resolution = parseInt(document.getElementById('resolution').value);
                showStatus('Starting client-side processing...', 'info');
                showProgress(true, 5, 'Initializing client-side processing...');

                // Use simplified client-side processing for demo
                const elevationData = await fetchElevationDataSimple(selectedBounds, resolution);

                if (isCancelled) {
                    throw new Error('Processing cancelled by user');
                }

                showProgress(true, 90, 'Generating STL file...');
                const stlContent = generateSTLSimple(elevationData, resolution);
                
                showProgress(true, 100, 'Complete!');
                downloadSTL(stlContent, resolution, 'client');
                
                showStatus('‚úÖ Client-side model generated successfully!', 'success');
                setTimeout(() => showProgress(false), 3000);

            } catch (error) {
                showProgress(false);
                if (error.message.includes('cancelled')) {
                    showStatus('Generation cancelled by user', 'warning');
                } else {
                    showStatus('Error: ' + error.message, 'error');
                }
            } finally {
                isProcessing = false;
                isCancelled = false;
                generateBtn.disabled = false;
                cancelBtn.style.display = 'none';
                checkGenerateButton();
            }
        }

        function cancelGeneration() {
            isCancelled = true;
            showStatus('Cancelling generation...', 'warning');
        }

        // Simplified client-side elevation fetching for demo
        async function fetchElevationDataSimple(bounds, resolution) {
            const latStep = (bounds.north - bounds.south) / resolution;
            const lngStep = (bounds.east - bounds.west) / resolution;
            const elevationData = [];
            const totalPoints = (resolution + 1) * (resolution + 1);
            
            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const lat = bounds.south + (i * latStep);
                    const lng = bounds.west + (j * lngStep);
                    
                    // Simulate realistic elevation data for terrain
                    const baseElevation = 100;
                    const terrainVariation = Math.sin(lat * 0.05) * Math.cos(lng * 0.05) * 300;
                    const detailVariation = Math.sin(lat * 0.2) * Math.cos(lng * 0.2) * 100;
                    const noise = (Math.random() - 0.5) * 50;
                    
                    const elevation = baseElevation + terrainVariation + detailVariation + noise;
                    
                    elevationData.push({
                        elevation: Math.max(0, elevation),
                        location: { lat, lng }
                    });
                    
                    if (elevationData.length % 1000 === 0) {
                        const progress = Math.round((elevationData.length / totalPoints) * 80);
                        showProgress(true, progress, `Processing ${elevationData.length}/${totalPoints} points...`);
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                    
                    if (isCancelled) {
                        throw new Error('Processing cancelled');
                    }
                }
            }
            
            return elevationData;
        }

        // Simplified STL generation for demo
        function generateSTLSimple(elevationData, resolution) {
            const exaggeration = parseFloat(document.getElementById('exaggeration').value);
            const baseHeight = parseFloat(document.getElementById('baseHeight').value);
            const modelSize = parseFloat(document.getElementById('modelSize').value);

            let minElevation = Math.min(...elevationData.map(p => p.elevation));
            let maxElevation = Math.max(...elevationData.map(p => p.elevation));
            
            if (minElevation === maxElevation) maxElevation = minElevation + 1;
            const elevationRange = maxElevation - minElevation;
            
            const grid = [];
            for (let i = 0; i <= resolution; i++) {
                grid[i] = [];
                for (let j = 0; j <= resolution; j++) {
                    const index = i * (resolution + 1) + j;
                    const elevation = elevationData[index].elevation;
                    const normalizedHeight = ((elevation - minElevation) / elevationRange) * 
                                           modelSize * 0.4 * exaggeration;
                    grid[i][j] = normalizedHeight + baseHeight;
                }
            }

            let stl = `solid client_terrain_${resolution}x${resolution}\n`;
            const step = modelSize / resolution;
            
            // Generate terrain surface
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const x1 = i * step, y1 = j * step;
                    const x2 = (i + 1) * step, y2 = (j + 1) * step;
                    
                    const z1 = grid[i][j], z2 = grid[i + 1][j];
                    const z3 = grid[i][j + 1], z4 = grid[i + 1][j + 1];
                    
                    stl += generateTriangle([x1, y1, z1], [x2, y1, z2], [x1, y2, z3]);
                    stl += generateTriangle([x2, y1, z2], [x2, y2, z4], [x1, y2, z3]);
                }
            }
            
            // Add bottom surface
            stl += generateTriangle([0, 0, 0], [0, modelSize, 0], [modelSize, 0, 0]);
            stl += generateTriangle([modelSize, 0, 0], [0, modelSize, 0], [modelSize, modelSize, 0]);
            
            // Add simplified side walls
            const wallHeight = Math.max(...grid.flat());
            stl += generateTriangle([0, 0, 0], [0, 0, wallHeight], [modelSize, 0, 0]);
            stl += generateTriangle([modelSize, 0, 0], [0, 0, wallHeight], [modelSize, 0, wallHeight]);
            stl += generateTriangle([0, modelSize, 0], [modelSize, modelSize, 0], [0, modelSize, wallHeight]);
            stl += generateTriangle([modelSize, modelSize, 0], [modelSize, modelSize, wallHeight], [0, modelSize, wallHeight]);
            
            stl += `endsolid client_terrain_${resolution}x${resolution}\n`;
            return stl;
        }

        function generateTriangle(v1, v2, v3) {
            const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
            const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
            
            const normal = [
                u[1] * v[2] - u[2] * v[1],
                u[2] * v[0] - u[0] * v[2],
                u[0] * v[1] - u[1] * v[0]
            ];
            
            const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
            if (length > 0) {
                normal[0] /= length;
                normal[1] /= length;
                normal[2] /= length;
            }
            
            return `  facet normal ${normal[0].toFixed(6)} ${normal[1].toFixed(6)} ${normal[2].toFixed(6)}\n` +
                   `    outer loop\n` +
                   `      vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n` +
                   `      vertex ${v2[0].toFixed(6)} ${v2[1].toFixed(6)} ${v2[2].toFixed(6)}\n` +
                   `      vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n` +
                   `    endloop\n` +
                   `  endfacet\n`;
        }

        function downloadSTL(stlContent, resolution, source) {
            const blob = new Blob([stlContent], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '_');
            const fileSize = (blob.size / 1024 / 1024).toFixed(1);
            
            a.download = `terrain_${source}_${resolution}x${resolution}_${timestamp}.stl`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus(`File downloaded: ${fileSize}MB STL with ${resolution}√ó${resolution} resolution`, 'success');
        }

        // Initialize
        updateEstimates();
        onProcessingModeChange();
        showStatus('Choose processing mode: Client-side (fast, keep browser open) or Server-side (slow, laptop can sleep)', 'info');
    </script>
</body>
</html>